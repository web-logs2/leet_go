package DFS____BFS

/**
基因序列可以表示为一条由 8 个字符组成的字符串，其中每个字符都是 'A'、'C'、'G' 和 'T' 之一。
假设我们需要调查从基因序列start 变为 end 所发生的基因变化。一次基因变化就意味着这个基因序列中的一个字符发生了变化。
例如，"AACCGGTT" --> "AACCGGTA" 就是一次基因变化。
另有一个基因库 bank 记录了所有有效的基因变化，只有基因库中的基因才是有效的基因序列。
给你两个基因序列 start 和 end ，以及一个基因库 bank ，请你找出并返回能够使start 变化为 end 所需的最少变化次数。
如果无法完成此基因变化，返回 -1 。
注意：起始基因序列start 默认是有效的，但是它并不一定会出现在基因库中。

**** 注意每一次变换后的序列必须是有效的，所以不能直接比较 start 和 end 的不同的位数，因为可能某一次变化不在bank池子里
**** 注意每一次变换后的序列必须是有效的，所以不能直接比较 start 和 end 的不同的位数，因为可能某一次变化不在bank池子里
**** 注意每一次变换后的序列必须是有效的，所以不能直接比较 start 和 end 的不同的位数，因为可能某一次变化不在bank池子里

思路：BFS
根据以上变换规则，我们可以进行尝试所有合法的基因变化，并找到最小的变换次数即可。步骤如下：
	1、如果 start 与 end 相等，此时直接返回 0；如果最终的基因序列不在 bank 中，则此时按照题意要求，无法生成，直接返回 −1；
	2、首先我们将可能变换的基因 s 从队列中取出，按照上述的变换规则，尝试所有可能的变化后的基因，比如一个 AACCGGTA，
	我们依次尝试改变基因 s 的一个字符，并尝试所有可能的基因变化序列， 变化一次最多可能会生成 3×8=24 种不同的基因序列。
	3、我们需要检测当前生成的基因序列的合法性 si 首先利用哈希表检测 si是否在数组 bank 中，如果是则认为该基因合法，
	否则改变化非法直接丢弃；其次我们还需要用哈希表记录已经遍历过的基因序列，如果该基因序列已经遍历过，则此时直接跳过；
	如果合法且未遍历过的基因序列，则我们将其加入到队列中。
	4、如果当前变换后的基因序列与 end 相等，则此时我们直接返回最小的变化次数即可；
	如果队列中所有的元素都已经遍历完成还无法变成 end，则此时无法实现目标变化，返回 -1。

T = O(C×n×m)，其中 n 为基因序列的长度8，m 为数组 bank 的长度。
对于队列中的每个合法的基因序列每次都需要计算 C×n 种变化，在这里 C=4；队列中最多有 m 个元素，因此时间复杂度为 O(C×n×m)。

S = O(n×m)，其中 n 为基因序列的长度，m 为数组 bank 的长度。合法性的哈希表中一共存有 m 个元素，队列中最多有 m 个元素，
每个元素的空间为 O(n)；因此空间复杂度为 O(n×m)。
*/
func minMutation(start, end string, bank []string) int {
	if start == end {
		return 0
	}
	bankSet := make(map[string]bool)
	for _, s := range bank {
		bankSet[s] = true
	}
	if _, ok := bankSet[end]; !ok {
		return -1
	}
	//待处理的队列
	q := []string{start}
	for step := 0; q != nil; step++ {
		tmp := q
		q = nil
		for _, cur := range tmp { //遍历当前一轮的队列里待处理的字符串
			for i, x := range cur { //遍历一个字符串中的每一个字符，ACGT 依次比较
				for _, y := range "ACGT" {
					if y != x { //说明x可以替换成y, 作为下一个字符串序列
						nxt := cur[:i] + string(y) + cur[i+1:]
						if _, ok := bankSet[nxt]; ok {
							if nxt == end {
								return step + 1
							}
							//bfs防止重复遍历已经处理过的序列，所以，处理过的合法序列，直接删除，下次再遇到同样的nxt,直接跳过
							delete(bankSet, nxt)
							q = append(q, nxt)
						}
					}
				}
			}
		}
	}
	return -1
}
