package 枚举

import "math"

/**
题目：
给定一个整数 n ，返回 可表示为两个 n 位整数乘积的 最大回文整数 。因为答案可能非常大，所以返回它对 1337 取余 。

思路：枚举 T= O(10^2n) S= O(1)
我们可以从大到小枚举回文数，由于确定了回文数的左半部分，其右半部分也就确定了，因此我们只需要枚举左半部分，
同时由于两个 n 位整数的乘积至多是个 2n 位数，我们可以从 10^n-1 开始枚举回文数的左半部分。
得到回文数 p 后，需要判断其能否分解成两个 n 位整数。
我们可以从 10^n-1 开始  从大到小  枚举 x，若 x 能整除 p 且 x 和 p/x均为 n 位整数，则 p 就是我们要找的答案。

代码实现时，在枚举 x 时 x从大到小 枚举到 「√p」 即可，因为继续枚举的话有 x<√p ，若 x 为 p 的因子则说明更大的 p/x 也是 p 的因子，但是前面枚举 x 的过程中并没有找到 p 的因子，矛盾。

*/
func largestPalindrome(n int) int {
	if n == 1 {
		return 9
	}
	upper := int(math.Pow10(n)) - 1 //n位数的上界
	for left := upper; ; left-- {   //这里left没有条件
		p := left //构造回文数p
		for x := left; x > 0; x /= 10 {
			p = p*10 + x%10 //翻转left，拼接到p的末尾，构造回文数
		}
		for x := upper; x*x >= p; x-- {
			if p%x == 0 {
				return p % 1337
			}
		}
	}
}
